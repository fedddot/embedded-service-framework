#ifndef	API_MESSAGE_READER_HPP
#define	API_MESSAGE_READER_HPP

/// @file nanopb_message_reader.hpp
/// @brief Template class for decoding Nanopb-serialized protocol buffer messages
/// @details Provides a reader interface that combines package reading and Nanopb decoding.
/// The reader extracts raw binary data using a PackageReader, decodes it using the Nanopb
/// library, and converts the decoded protocol buffer message into a user-defined API type.
/// This abstraction handles all necessary memory management and protocol buffer lifecycle.

#include <cstdint>
#include <cstring>
#include <functional>
#include <optional>
#include <stdexcept>
#include <vector>

#include "pb_decode.h"

#include "data_reader.hpp"

namespace ipc {

	/// @brief Template class for decoding Nanopb-serialized protocol buffer messages
	/// 
	/// @tparam ApiMessage The target API message type used by the service busyness logic
	/// @tparam NanoPbMessage The corresponding Nano PB message type generated by the Nano PB generator
	///
	/// Aggregates an instance of PackageReader (see below) responsible to read a raw data encoding a single ApiMessage.
	/// Uses Nano PB lib to parse a Nano PB generated type NanoPbMessage, and then uses user defined function to transform it into the target ApiMessage type
	template <typename ApiMessage, typename NanoPbMessage>
	class NanopbMessageReader: public DataReader<std::optional<ApiMessage>> {
	public:
		/// @brief A data reader responsible for reading a single ApiMessage raw data package
		using PackageReader = DataReader<std::optional<std::vector<std::uint8_t>>>;

		/// @brief Function for converting Nanopb messages to API messages
		using NanoPbToApiMessageFunc = std::function<ApiMessage(const NanoPbMessage&)>;

		/// @brief Function for initializing Nanopb message structures
		/// Sometimes when dealing with NanoPB messages, you might need to initialize some fields (such as strings and repeated elenemts(arrays)) with a decode callback and an opaque argument to make the whole message decoding possible. The exact initialization process depends on the specific proto structure and needs to be defined by the user.
		using NanoPbMessageInitFunc = std::function<NanoPbMessage()>;

		/// @brief Function type for cleaning up Nanopb message structures
		/// Called when a message created by NanoPbMessageInitFunc is not used anymore and can be deleted. Should delete (free) all the resources allocated by function NanoPbMessageInitFunc.
		using NanoPbMessageDeinitFunc = std::function<void(NanoPbMessage *)>;

		/// @brief Constructs a new Nanopb Message Reader
		/// 
		/// @param package_reader_ptr Pointer to the package reader that provides raw message data packets (single packet per single message)
		/// @param nano_pb_to_api_msg Function to convert from Nanopb message to API message
		/// @param init_nanopb_message Function to initialize a new Nanopb message structure
		/// @param deinit_nanopb_message Function to clean up a Nanopb message structure
		/// @param nanopb_message_fields Pointer to Nanopb message field descriptions (provided by the generated nano pb header)
		/// 
		/// @throw std::invalid_argument if any of the parameters is null
		NanopbMessageReader(
			PackageReader *package_reader_ptr,
			const NanoPbToApiMessageFunc& nano_pb_to_api_msg,
			const NanoPbMessageInitFunc& init_nanopb_message,
			const NanoPbMessageDeinitFunc& deinit_nanopb_message,
			const pb_msgdesc_t *nanopb_message_fields
		): m_package_reader_ptr(package_reader_ptr), m_nano_pb_to_api_msg(nano_pb_to_api_msg), m_init_nanopb_message(init_nanopb_message), m_deinit_nanopb_message(deinit_nanopb_message), m_nanopb_message_fields(nanopb_message_fields) {
			if (!m_package_reader_ptr || !m_nano_pb_to_api_msg || !m_init_nanopb_message || !m_deinit_nanopb_message || !m_nanopb_message_fields) {
				throw std::invalid_argument("invalid args received");
			}
		}
		NanopbMessageReader(const NanopbMessageReader&) = default;
		NanopbMessageReader& operator=(const NanopbMessageReader&) = default;

		/// @brief Reads an API Message
		/// 
		/// @return std::optional<ApiMessage> The converted API message if available, std::nullopt if no data is available
		/// @throw std::runtime_error if Nanopb message decoding fails
		std::optional<ApiMessage> read() override {
			const auto package_data = m_package_reader_ptr->read();
			if (!package_data) {
				return std::nullopt;
			}
			auto stream = pb_istream_from_buffer((*package_data).data(), (*package_data).size());
			NanoPbMessage pb_message = m_init_nanopb_message();
			if (!pb_decode(&stream, m_nanopb_message_fields, &pb_message)) {
				m_deinit_nanopb_message(&pb_message);
                throw std::runtime_error("failed to decode Nano PB message: " + std::string(PB_GET_ERROR(&stream)));
            }
			const auto api_message(m_nano_pb_to_api_msg(pb_message));
			m_deinit_nanopb_message(&pb_message);
			return api_message;
		}
	private:
		PackageReader *m_package_reader_ptr;
		NanoPbToApiMessageFunc m_nano_pb_to_api_msg;
		NanoPbMessageInitFunc m_init_nanopb_message;
		NanoPbMessageDeinitFunc m_deinit_nanopb_message;
		const pb_msgdesc_t *m_nanopb_message_fields;
	};
}

#endif // API_MESSAGE_READER_HPP