#ifndef	NANOPB_MESSAGE_WRITER_HPP
#define	NANOPB_MESSAGE_WRITER_HPP

/// @file nanopb_message_writer.hpp
/// @brief Template class for encoding and writing API messages using Nanopb
/// @details Provides a writer interface that combines API message serialization and package writing.
/// The writer converts API messages to Nanopb format, encodes them using the Nanopb
/// library, and writes the resulting binary data using a package writer.
/// This abstraction handles all necessary memory management and protocol buffer lifecycle.

#include <cstddef>
#include <cstdint>
#include <functional>
#include <stdexcept>
#include <vector>

#include "data_writer.hpp"
#include "pb.h"
#include "pb_encode.h"

namespace ipc {

	/// @brief A writer for encoding and serializing API messages using Nanopb protocol buffers
	/// 
	/// @tparam ApiMessage The source API message type used in the service business logic.
	///                    This is typically a domain-specific message type that's independent
	///                    of the serialization format.
	/// @tparam NanoPbMessage The corresponding Nanopb-generated message type.
	///                       This type is automatically generated by the Nanopb generator
	///                       from .proto files.
	/// @tparam MAX_MSG_SIZE Maximum size in bytes for a serialized message.
	///                      Must be large enough to hold the largest possible message
	///                      after protocol buffer encoding.
	///
	/// This class provides a high-level interface for writing API messages:
	/// 1. Converts ApiMessage to NanoPbMessage using user-provided conversion function
	/// 2. Encodes the NanoPbMessage into binary format using the Nanopb library
	/// 3. Writes the encoded data using PackageWriter
	/// 
	/// The class ensures proper memory management and handles message size limitations.
	template <typename ApiMessage, typename NanoPbMessage, std::size_t MAX_MSG_SIZE>
	class NanopbMessageWriter: public DataWriter<ApiMessage> {
	public:
		/// @brief Writer for encoded message data packets
		/// @details Provides an interface for writing binary data packets, where each packet
		///          contains exactly one serialized protocol buffer message
		using PackageWriter = DataWriter<std::vector<std::uint8_t>>;

		/// @brief Converter function from API messages to Nanopb messages
		/// @details This function should implement the conversion logic from the high-level
		///          API message type to the low-level Nanopb-generated type
		using ApiMessageToNanoPbFunc = std::function<NanoPbMessage(const ApiMessage&)>;

		/// @brief Function for cleaning up Nanopb message structures
		/// @details Called to clean up resources when a Nanopb message is no longer needed.
		///          Must free all resources allocated during message conversion:
		///          - Dynamically allocated strings
		///          - Array buffers for repeated fields
		///          - Any other dynamically allocated resources
		using NanoPbMessageDeinitFunc = std::function<void(NanoPbMessage *)>;
		/// @brief Constructs a new Nanopb Message Writer
		/// 
		/// @param package_writer_ptr Pointer to the package writer for writing encoded message packets
		/// @param api_msg_to_nano_pb Function to convert from API message to Nanopb message
		/// @param deinit_nanopb_message Function to clean up a Nanopb message structure
		/// @param nanopb_message_fields Pointer to Nanopb message field descriptions (provided by the generated nanopb header)
		/// 
		/// @throw std::invalid_argument if package_writer_ptr or api_msg_to_nano_pb is null
		NanopbMessageWriter(
			PackageWriter *package_writer_ptr,
			const ApiMessageToNanoPbFunc& api_msg_to_nano_pb,
			const NanoPbMessageDeinitFunc& deinit_nanopb_message,
			const pb_msgdesc_t *nanopb_message_fields
		): m_package_writer_ptr(package_writer_ptr), m_api_msg_to_nano_pb(api_msg_to_nano_pb), m_deinit_nanopb_message(deinit_nanopb_message), m_nanopb_message_fields(nanopb_message_fields) {
			if (!m_package_writer_ptr || !m_api_msg_to_nano_pb) {
				throw std::invalid_argument("invalid args received");
			}
		}
		NanopbMessageWriter(const NanopbMessageWriter&) = default;
		NanopbMessageWriter& operator=(const NanopbMessageWriter&) = delete;
		/// @brief Writes an API message by converting and encoding it to protocol buffer format
		/// 
		/// @param message The API message to write
		/// @throw std::runtime_error if the message encoding fails or exceeds MAX_MSG_SIZE
		void write(const ApiMessage& message) override {
			auto pb_message = m_api_msg_to_nano_pb(message);
			pb_byte_t buff[MAX_MSG_SIZE] = { 0 };
			pb_ostream_t ostream = pb_ostream_from_buffer(
                buff,
                MAX_MSG_SIZE
            );
            if (!pb_encode(&ostream, m_nanopb_message_fields, &pb_message)) {
				m_deinit_nanopb_message(&pb_message);
                throw std::runtime_error("failed to encode api message into protocol buffer: " + std::string(PB_GET_ERROR(&ostream)));
            }
			m_deinit_nanopb_message(&pb_message);
            m_package_writer_ptr->write(std::vector<std::uint8_t>((const char *)buff, (const char *)buff + ostream.bytes_written));
		}
	private:
		PackageWriter *m_package_writer_ptr;
		const ApiMessageToNanoPbFunc m_api_msg_to_nano_pb;
		NanoPbMessageDeinitFunc m_deinit_nanopb_message;
		const pb_msgdesc_t *m_nanopb_message_fields;
	};
}

#endif // NANOPB_MESSAGE_WRITER_HPP